var documenterSearchIndex = {"docs":
[{"location":"generated/HowTo/overlapcorrectedLDA_options/","page":"Overlap corrected, multi-event, many options, LDA","title":"Overlap corrected, multi-event, many options, LDA","text":"using UnfoldDecode\nusing UnfoldSim\nusing UnfoldMakie\nusing CairoMakie\nusing Unfold","category":"page"},{"location":"generated/HowTo/overlapcorrectedLDA_options/#Overlap-corrected-decoding","page":"Overlap corrected, multi-event, many options, LDA","title":"Overlap-corrected decoding","text":"","category":"section"},{"location":"generated/HowTo/overlapcorrectedLDA_options/","page":"Overlap corrected, multi-event, many options, LDA","title":"Overlap corrected, multi-event, many options, LDA","text":"We will try to introduce as many fancy features as possible Please read the \"tutorial\" first","category":"page"},{"location":"generated/HowTo/overlapcorrectedLDA_options/#Simulation","page":"Overlap corrected, multi-event, many options, LDA","title":"Simulation","text":"","category":"section"},{"location":"generated/HowTo/overlapcorrectedLDA_options/","page":"Overlap corrected, multi-event, many options, LDA","title":"Overlap corrected, multi-event, many options, LDA","text":"multi-event","category":"page"},{"location":"generated/HowTo/overlapcorrectedLDA_options/","page":"Overlap corrected, multi-event, many options, LDA","title":"Overlap corrected, multi-event, many options, LDA","text":"dat, evt = UnfoldSim.predef_eeg()\nevt.event = rand([\"eventA\", \"eventB\"], size(evt, 1)) # add random events\ndat = repeat(dat', 5)\ndat .= dat .+ 20 .* rand(size(dat)...)","category":"page"},{"location":"generated/HowTo/overlapcorrectedLDA_options/#Overlap-model-Definition","page":"Overlap corrected, multi-event, many options, LDA","title":"Overlap-model Definition","text":"","category":"section"},{"location":"generated/HowTo/overlapcorrectedLDA_options/","page":"Overlap corrected, multi-event, many options, LDA","title":"Overlap corrected, multi-event, many options, LDA","text":"We have two basis functions now, with two different timewindows. Let's see if it works!","category":"page"},{"location":"generated/HowTo/overlapcorrectedLDA_options/","page":"Overlap corrected, multi-event, many options, LDA","title":"Overlap corrected, multi-event, many options, LDA","text":"des = [\n    \"eventA\" => (@formula(0 ~ 1 + condition + continuous), firbasis((-0.1, 1.0), 100)),\n    \"eventB\" => (@formula(0 ~ 1 + continuous), firbasis((-0.3, 0.5), 100)),\n]","category":"page"},{"location":"generated/HowTo/overlapcorrectedLDA_options/","page":"Overlap corrected, multi-event, many options, LDA","title":"Overlap corrected, multi-event, many options, LDA","text":"To show that it is possible, we explicitly specify the solver","category":"page"},{"location":"generated/HowTo/overlapcorrectedLDA_options/","page":"Overlap corrected, multi-event, many options, LDA","title":"Overlap corrected, multi-event, many options, LDA","text":"customsolver = (x, y) -> Unfold.solver_default(x, y)\nuf = Unfold.fit(UnfoldModel, des, evt, dat[1, :]; solver = customsolver);\nplot_erp(coeftable(uf); mapping = (; col = :eventname))","category":"page"},{"location":"generated/HowTo/overlapcorrectedLDA_options/#Fitting-the-Overlap-corrected-LDA-model","page":"Overlap corrected, multi-event, many options, LDA","title":"Fitting the Overlap-corrected LDA model","text":"","category":"section"},{"location":"generated/HowTo/overlapcorrectedLDA_options/","page":"Overlap corrected, multi-event, many options, LDA","title":"Overlap corrected, multi-event, many options, LDA","text":"using MLJ, MultivariateStats, MLJMultivariateStatsInterface\nLDA = @load LDA pkg = MultivariateStats","category":"page"},{"location":"generated/HowTo/overlapcorrectedLDA_options/","page":"Overlap corrected, multi-event, many options, LDA","title":"Overlap corrected, multi-event, many options, LDA","text":"you could use other parameters, check out ?LDA","category":"page"},{"location":"generated/HowTo/overlapcorrectedLDA_options/","page":"Overlap corrected, multi-event, many options, LDA","title":"Overlap corrected, multi-event, many options, LDA","text":"ldaModel = LDA(\n    method = :whiten,\n    cov_w = SimpleCovariance(),\n    cov_b = SimpleCovariance(),\n    regcoef = 1e-3,\n)\n\nuf_lda = UnfoldDecode.fit(\n    UnfoldDecodingModel,\n    des,\n    evt,\n    dat,\n    ldaModel,\n    \"eventA\" => :condition;\n    nfolds = 2,# only 2 folds to speed up computation\n    unfold_fit_options = (; solver = customsolver), #customer solver for fun\n    eventcolumn = :event, # actually the default, but maybe your event dataframe has a different name?\n    multithreading = false,\n) # who needs speed anyway :shrug:\n\nplot_erp(coeftable(uf_lda))","category":"page"},{"location":"generated/HowTo/overlapcorrectedLDA_options/","page":"Overlap corrected, multi-event, many options, LDA","title":"Overlap corrected, multi-event, many options, LDA","text":"Voila, the model classified the correct period at the correct event","category":"page"},{"location":"generated/HowTo/overlapcorrectedLDA_options/","page":"Overlap corrected, multi-event, many options, LDA","title":"Overlap corrected, multi-event, many options, LDA","text":"","category":"page"},{"location":"generated/HowTo/overlapcorrectedLDA_options/","page":"Overlap corrected, multi-event, many options, LDA","title":"Overlap corrected, multi-event, many options, LDA","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/tutorials/b2b_quickstart/#Setup","page":"Quick Start b2b","title":"Setup","text":"","category":"section"},{"location":"generated/tutorials/b2b_quickstart/","page":"Quick Start b2b","title":"Quick Start b2b","text":"using Unfold\nusing UnfoldMakie, CairoMakie\nusing UnfoldSim\nusing UnfoldDecode\nusing DataFrames\nusing Statistics","category":"page"},{"location":"generated/tutorials/b2b_quickstart/#quickstart-b2b","page":"Quick Start b2b","title":"Quick start of Back-To-Back (b2b)","text":"","category":"section"},{"location":"generated/tutorials/b2b_quickstart/#Data-generation","page":"Quick Start b2b","title":"Data generation","text":"","category":"section"},{"location":"generated/tutorials/b2b_quickstart/#Simulation-and-data-collection","page":"Quick Start b2b","title":"Simulation and data collection","text":"","category":"section"},{"location":"generated/tutorials/b2b_quickstart/","page":"Quick Start b2b","title":"Quick Start b2b","text":"Generate single channel data via UnfoldSim.jl","category":"page"},{"location":"generated/tutorials/b2b_quickstart/","page":"Quick Start b2b","title":"Quick Start b2b","text":"dat, evts = UnfoldSim.predef_eeg(; noiselevel = 0.1, return_epoched = true);\nnothing #hide","category":"page"},{"location":"generated/tutorials/b2b_quickstart/","page":"Quick Start b2b","title":"Quick Start b2b","text":"dat is a time x repetition Matrix, evts is a DataFrame`with independent variables / features to explain the data","category":"page"},{"location":"generated/tutorials/b2b_quickstart/#Dimension-expansion","page":"Quick Start b2b","title":"Dimension expansion","text":"","category":"section"},{"location":"generated/tutorials/b2b_quickstart/","page":"Quick Start b2b","title":"Quick Start b2b","text":"Repeat the dat 20 times, representing 20 channels. In the future we will replace this with a direct multi-channel simulation.","category":"page"},{"location":"generated/tutorials/b2b_quickstart/","page":"Quick Start b2b","title":"Quick Start b2b","text":"dat_3d = permutedims(repeat(dat, 1, 1, 20), [3 1 2]);\nnothing #hide","category":"page"},{"location":"generated/tutorials/b2b_quickstart/","page":"Quick Start b2b","title":"Quick Start b2b","text":"Channels shouldnt be identical, so we add some noise.","category":"page"},{"location":"generated/tutorials/b2b_quickstart/","page":"Quick Start b2b","title":"Quick Start b2b","text":"dat_3d .+= 0.1 * rand(size(dat_3d)...);\nnothing #hide","category":"page"},{"location":"generated/tutorials/b2b_quickstart/#Modeling","page":"Quick Start b2b","title":"Modeling","text":"","category":"section"},{"location":"generated/tutorials/b2b_quickstart/#Solver-selection","page":"Quick Start b2b","title":"Solver selection","text":"","category":"section"},{"location":"generated/tutorials/b2b_quickstart/","page":"Quick Start b2b","title":"Quick Start b2b","text":"Call b2b solver in UnfoldDecode","category":"page"},{"location":"generated/tutorials/b2b_quickstart/","page":"Quick Start b2b","title":"Quick Start b2b","text":"b2b_solver = (x, y) -> UnfoldDecode.solver_b2b(x, y; cross_val_reps = 5);\nnothing #hide","category":"page"},{"location":"generated/tutorials/b2b_quickstart/","page":"Quick Start b2b","title":"Quick Start b2b","text":"hint: Hint\none could specify the specific solvers for G and H by passing the solver_G and solver_H parameters to the solver_b2b function. Implemented solvers are ridge, lasso, lsq, svm, but other solvers from MLJ.jl can be used as well.","category":"page"},{"location":"generated/tutorials/b2b_quickstart/#Generate-the-formula","page":"Quick Start b2b","title":"Generate the formula","text":"","category":"section"},{"location":"generated/tutorials/b2b_quickstart/","page":"Quick Start b2b","title":"Quick Start b2b","text":"We want to decode condition, but simultaneously control for the effect of continuous.","category":"page"},{"location":"generated/tutorials/b2b_quickstart/","page":"Quick Start b2b","title":"Quick Start b2b","text":"f = @formula 0 ~ 1 + condition + continuous\ntime = range(0, 0.44, step = 1 / 100)\ndesignDict = [Any => (f, time)]\n\nm = Unfold.fit(UnfoldModel, designDict, evts, dat_3d; solver = b2b_solver);\n\nresults = coeftable(m);\nresults.estimate = abs.(results.estimate); ## back2back has no sign\nresults = results[results.coefname.!=\"(Intercept)\", :] ## the intercept in b2b is hard to interpret","category":"page"},{"location":"generated/tutorials/b2b_quickstart/#Plotting","page":"Quick Start b2b","title":"Plotting","text":"","category":"section"},{"location":"generated/tutorials/b2b_quickstart/","page":"Quick Start b2b","title":"Quick Start b2b","text":"plot_erp(results; axis = (xlabel = \"Time [s]\", ylabel = \"Performance\"))","category":"page"},{"location":"generated/tutorials/b2b_quickstart/","page":"Quick Start b2b","title":"Quick Start b2b","text":"We can see from the graph that b2b solver identifies regions where the signal can be decoded, taking into account the continuous feature","category":"page"},{"location":"generated/tutorials/b2b_quickstart/","page":"Quick Start b2b","title":"Quick Start b2b","text":"","category":"page"},{"location":"generated/tutorials/b2b_quickstart/","page":"Quick Start b2b","title":"Quick Start b2b","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/explanations/b2b_why/","page":"Why Back2Back","title":"Why Back2Back","text":"using Unfold\nusing UnfoldMakie, CairoMakie\nusing UnfoldSim\nusing UnfoldDecode\nusing DataFrames\nusing Statistics\ninclude(\"../../../example_rename_events.jl\")","category":"page"},{"location":"generated/explanations/b2b_why/#explainer-b2b","page":"Why Back2Back","title":"Motivation for BacktoBack","text":"","category":"section"},{"location":"generated/explanations/b2b_why/#Introduction","page":"Why Back2Back","title":"Introduction","text":"","category":"section"},{"location":"generated/explanations/b2b_why/","page":"Why Back2Back","title":"Why Back2Back","text":"â€œBack-to-Backâ€ regression (B2B) is an approach to estimate the decoding performance from a set of correlated factors. Why do we need this? Let's have a look at a simple example: (Image: My Image)","category":"page"},{"location":"generated/explanations/b2b_why/","page":"Why Back2Back","title":"Why Back2Back","text":"Imagine we record EEG data from an eyetracking experiment, and investigate each fixation (a resting period of the eye) as an event for an ERP. Imagine, we have both cats and dogs, but that we also make large and small eye-movements.","category":"page"},{"location":"generated/explanations/b2b_why/#Data-generation","page":"Why Back2Back","title":"Data generation","text":"","category":"section"},{"location":"generated/explanations/b2b_why/#Simulation-and-data-collection","page":"Why Back2Back","title":"Simulation and data collection","text":"","category":"section"},{"location":"generated/explanations/b2b_why/","page":"Why Back2Back","title":"Why Back2Back","text":"Collect the data genarated by UnfoldSim, and add certian level of noise","category":"page"},{"location":"generated/explanations/b2b_why/","page":"Why Back2Back","title":"Why Back2Back","text":"dat, evts = UnfoldSim.predef_eeg(; noiselevel = 0.1, return_epoched = true);\nevts = example_rename_events(evts);\nnothing #hide","category":"page"},{"location":"generated/explanations/b2b_why/#Data-further-generating","page":"Why Back2Back","title":"Data further generating","text":"","category":"section"},{"location":"generated/explanations/b2b_why/","page":"Why Back2Back","title":"Why Back2Back","text":"To make the example more impressive, let's add an orthogonal variable vegetable. But this variable is special: It is correlated with the covariate eye_movement_size.","category":"page"},{"location":"generated/explanations/b2b_why/","page":"Why Back2Back","title":"Why Back2Back","text":"evts.vegetable .=\n    [\"tomato\", \"carrot\"][1 .+ (evts.eye_movement_size .+ 10 .* rand(size(evts, 1)) .> 7.5)];\ncor(evts.eye_movement_size, evts.vegetable .== \"carrot\")","category":"page"},{"location":"generated/explanations/b2b_why/","page":"Why Back2Back","title":"Why Back2Back","text":"(Image: My Image)","category":"page"},{"location":"generated/explanations/b2b_why/","page":"Why Back2Back","title":"Why Back2Back","text":"Summarized, we have three independent variables: animal, eye_movement_size, and vegetable, with the latter two being correlated.","category":"page"},{"location":"generated/explanations/b2b_why/","page":"Why Back2Back","title":"Why Back2Back","text":"important: Important\nBy construction, there is no vegetable effect in the data! All effects we find for vegetable solely come from the correlation with eye_movement_size - Now imagine decoding vegetable, you would find a strong spurious effect.","category":"page"},{"location":"generated/explanations/b2b_why/#Making-it-multi-channel","page":"Why Back2Back","title":"Making it multi channel","text":"","category":"section"},{"location":"generated/explanations/b2b_why/","page":"Why Back2Back","title":"Why Back2Back","text":"Decoding is multivariate, so we need multiple channels. For simplicity, we just repeat the data 20 times, representing 20 channels.","category":"page"},{"location":"generated/explanations/b2b_why/","page":"Why Back2Back","title":"Why Back2Back","text":"dat_3d = permutedims(repeat(dat, 1, 1, 20), [3 1 2]);\ndat_3d .+= 0.1 * rand(size(dat_3d)...);\nnothing #hide","category":"page"},{"location":"generated/explanations/b2b_why/#Solver-selection","page":"Why Back2Back","title":"Solver selection","text":"","category":"section"},{"location":"generated/explanations/b2b_why/","page":"Why Back2Back","title":"Why Back2Back","text":"b2b_solver = (x, y) -> UnfoldDecode.solver_b2b(x, y; cross_val_reps = 5);\nnothing #hide","category":"page"},{"location":"generated/explanations/b2b_why/#Fitting-function","page":"Why Back2Back","title":"Fitting function","text":"","category":"section"},{"location":"generated/explanations/b2b_why/","page":"Why Back2Back","title":"Why Back2Back","text":"Because we want to compare different scenarios involving different variables, we define a function to estimate them.","category":"page"},{"location":"generated/explanations/b2b_why/","page":"Why Back2Back","title":"Why Back2Back","text":"function run_b2b(f)\n    # Define a design dictionary according to the formula\n    times = range(0, 0.44, step = 1 / 100)\n    designDict = [Any => (f, times)]\n    # Fit the model\n    m = Unfold.fit(UnfoldModel, designDict, evts, dat_3d; solver = b2b_solver)\n\n    results = coeftable(m)\n    results.estimate = abs.(results.estimate)\n    results = results[results.coefname .!= \"(Intercept)\", :]\n    results.formula .= string(f)\n    return results\nend;\nnothing #hide","category":"page"},{"location":"generated/explanations/b2b_why/","page":"Why Back2Back","title":"Why Back2Back","text":"let's run a decoder without accounting for the other factors","category":"page"},{"location":"generated/explanations/b2b_why/","page":"Why Back2Back","title":"Why Back2Back","text":"results_all = map(\n    run_b2b,\n    [\n        @formula(0 ~ 1 + animal),\n        @formula(0 ~ 1 + vegetable),\n        @formula(0 ~ 1 + eye_movement_size)\n    ],\n)\nplot_erp(vcat(results_all...); axis = (xlabel = \"Time [s]\", ylabel = \"Performance\"))","category":"page"},{"location":"generated/explanations/b2b_why/","page":"Why Back2Back","title":"Why Back2Back","text":"As one can see, all three variables can be decoded well. Even though vegetable had no effect on the data!!","category":"page"},{"location":"generated/explanations/b2b_why/","page":"Why Back2Back","title":"Why Back2Back","text":"Let's now use B2B to take into account the correlation between vegetable and eye_movement_size:","category":"page"},{"location":"generated/explanations/b2b_why/","page":"Why Back2Back","title":"Why Back2Back","text":"results_all = map(\n    run_b2b,\n    [@formula(0 ~ 1 + vegetable), @formula(0 ~ 1 + vegetable + eye_movement_size)],\n)\nplot_erp(\n    vcat(results_all...);\n    mapping = (; color = :coefname, row = :formula),\n    axis = (xlabel = \"Time [s]\", ylabel = \"Performance\"),\n)","category":"page"},{"location":"generated/explanations/b2b_why/","page":"Why Back2Back","title":"Why Back2Back","text":"As can be seen, when modelling both effects (lower plot), the vegetable effect (correctly and as intended) vanishes. We now learned, that decodable information is only in  eye_movement_size, but not vegetable, which is \"just\" correlated","category":"page"},{"location":"generated/explanations/b2b_why/","page":"Why Back2Back","title":"Why Back2Back","text":"For completeness sake, we also include the comparison to a non-correlated effect","category":"page"},{"location":"generated/explanations/b2b_why/","page":"Why Back2Back","title":"Why Back2Back","text":"results_all = map(\n    run_b2b,\n    [@formula(0 ~ 1 + animal), @formula(0 ~ 1 + animal + vegetable + eye_movement_size)],\n)\nplot_erp(\n    vcat(results_all...);\n    mapping = (; color = :coefname, row = :formula),\n    axis = (xlabel = \"Time [s]\", ylabel = \"Performance\"),\n)","category":"page"},{"location":"generated/explanations/b2b_why/","page":"Why Back2Back","title":"Why Back2Back","text":"the animal effect remains untouched :)","category":"page"},{"location":"generated/explanations/b2b_why/","page":"Why Back2Back","title":"Why Back2Back","text":"","category":"page"},{"location":"generated/explanations/b2b_why/","page":"Why Back2Back","title":"Why Back2Back","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/reference/b2b_algorithms/","page":"Algorithm choice","title":"Algorithm choice","text":"using Unfold\nusing UnfoldMakie, CairoMakie\nusing UnfoldSim\nusing UnfoldDecode\nusing DataFrames\nusing Statistics\ninclude(\"../../../example_rename_events.jl\")","category":"page"},{"location":"generated/reference/b2b_algorithms/#Comparison-of-different-solvers-for-G-and-H","page":"Algorithm choice","title":"Comparison of different solvers for G and H","text":"","category":"section"},{"location":"generated/reference/b2b_algorithms/","page":"Algorithm choice","title":"Algorithm choice","text":"Let's prepare some data again","category":"page"},{"location":"generated/reference/b2b_algorithms/","page":"Algorithm choice","title":"Algorithm choice","text":"dat, evts = UnfoldSim.predef_eeg(; noiselevel = 0.1, return_epoched = true);\ndat_3d = permutedims(repeat(dat, 1, 1, 20), [3 1 2]);\ndat_3d .+= range(5, 20, size(dat_3d, 1)) .* rand(size(dat_3d)...); # vary the noise per channel\nevts.correlated .=\n    [\"tomato\", \"carrot\"][1 .+ (evts.continuous .+ 10 .* rand(size(evts, 1)) .> 7.5)];\nnothing #hide","category":"page"},{"location":"generated/reference/b2b_algorithms/#Comparison-of-the-results-from-different-regression-methods","page":"Algorithm choice","title":"Comparison of the results from different regression methods","text":"","category":"section"},{"location":"generated/reference/b2b_algorithms/","page":"Algorithm choice","title":"Algorithm choice","text":"function run_b2b(solver_G, solver_H; kwargs...)\n    b2b_solver = (x, y) -> UnfoldDecode.solver_b2b(x, y; solver_G, solver_H, kwargs...)\n\n    f = @formula(0 ~ 1 + condition + continuous + correlated)\n    # Define a design dictionary according to the formula\n    times = range(0, 0.44, step = 1 / 100)\n    designDict = [Any => (f, times)]\n    # Fit the model\n    m = Unfold.fit(UnfoldModel, designDict, evts, dat_3d; solver = b2b_solver)\n\n    results = coeftable(m)\n    results.estimate = abs.(results.estimate)\n    results = results[results.coefname .!= \"(Intercept)\", :]\n    results.solver_G .= string(solver_G)\n    results.solver_H .= string(solver_H)\n    return results\nend;\n\nrun_models(list) = vcat(map(m -> run_b2b(m...; multithreading = true), list)...)\nresults_all = run_models([\n    [UnfoldDecode.model_lsq, UnfoldDecode.model_lsq],\n    [UnfoldDecode.model_xgboost, UnfoldDecode.model_lsq],\n    [UnfoldDecode.model_ridge, UnfoldDecode.model_ridge],\n    [UnfoldDecode.model_ridge, UnfoldDecode.model_lsq],\n])\n\nplot_erp(\n    results_all;\n    mapping = (; col = :solver_G, row = :solver_H),\n    xis = (xlabel = \"Time [s]\", ylabel = \"Performance\"),\n)","category":"page"},{"location":"generated/reference/b2b_algorithms/","page":"Algorithm choice","title":"Algorithm choice","text":"Not all combinations are calculated due to time reason.","category":"page"},{"location":"generated/reference/b2b_algorithms/","page":"Algorithm choice","title":"Algorithm choice","text":"","category":"page"},{"location":"generated/reference/b2b_algorithms/","page":"Algorithm choice","title":"Algorithm choice","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#UnfoldDecode.jl-Documentation","page":"Home","title":"UnfoldDecode.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<div style=\"width:60%; margin: auto;\">\n</div>","category":"page"},{"location":"","page":"Home","title":"Home","text":"In UnfoldDecode.jl we develop new approaches, collect other algorithms, and provide tutorials, to decode overlapping and/or covariate-heavy EEG data.","category":"page"},{"location":"#Key-features","page":"Home","title":"Key features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This toolbox right now implements:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Overlap-corrected decoding ala Gal Vishne, Leon Deouell et al.\nCovariate-corrected decoding ala back-to-back regression, Jean-Remy King et al.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"UnfoldDecode\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more detailed instructions please refer to Installing Julia & Unfold Packages.","category":"page"},{"location":"#Usage-example","page":"Home","title":"Usage example","text":"","category":"section"},{"location":"#Where-to-start:-Learning-roadmap","page":"Home","title":"Where to start: Learning roadmap","text":"","category":"section"},{"location":"#First-steps-B2B","page":"Home","title":"First steps B2B","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ðŸ“Œ Goal: Learn why to use back-to-back regression, next learn how easy it is to apply it to your data \nðŸ”— B2B explained, B2B quickstart","category":"page"},{"location":"#First-Steps-Overlap-correction","page":"Home","title":"First Steps Overlap correction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ðŸ“Œ Goal: Learn how to run overlap corrected Unfold-style deconvolution models \nðŸ”— overlap-corrected decoding tutorial","category":"page"},{"location":"#Statement-of-need","page":"Home","title":"Statement of need","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<!---\nNote: The statement of need is also used in the `README.md`. Make sure that they are synchronized.\n-->","category":"page"},{"location":"generated/tutorials/overlapcorrectedLDA/","page":"Overlap corrected LDA","title":"Overlap corrected LDA","text":"using UnfoldDecode\nusing UnfoldSim\nusing UnfoldMakie\nusing CairoMakie\nusing Unfold","category":"page"},{"location":"generated/tutorials/overlapcorrectedLDA/#tutorial-overlap-decoding","page":"Overlap corrected LDA","title":"Overlap-corrected decoding tutorial","text":"","category":"section"},{"location":"generated/tutorials/overlapcorrectedLDA/","page":"Overlap corrected LDA","title":"Overlap corrected LDA","text":"This approach follows the work of the Deoulle Group, especially Gal Vishne's work as published 2023: https://doi.org/10.1101/2023.06.28.546397","category":"page"},{"location":"generated/tutorials/overlapcorrectedLDA/#Simulation","page":"Overlap corrected LDA","title":"Simulation","text":"","category":"section"},{"location":"generated/tutorials/overlapcorrectedLDA/","page":"Overlap corrected LDA","title":"Overlap corrected LDA","text":"We start with simulating some continuous, overlapping data with two conditions. As of now, UnfoldSim doesnt support multichannel, so we simply repeat the channel and add some noise`","category":"page"},{"location":"generated/tutorials/overlapcorrectedLDA/","page":"Overlap corrected LDA","title":"Overlap corrected LDA","text":"dat, evt = UnfoldSim.predef_eeg()\ndat = repeat(dat', 5)\ndat .= dat .+ 20 .* rand(size(dat)...)","category":"page"},{"location":"generated/tutorials/overlapcorrectedLDA/#Overlap-model-Definition","page":"Overlap corrected LDA","title":"Overlap-model Definition","text":"","category":"section"},{"location":"generated/tutorials/overlapcorrectedLDA/","page":"Overlap corrected LDA","title":"Overlap corrected LDA","text":"We have to define what model we want to use for overlap correction We decide for a one-basisfunction model, with one one condition and one covariate, from -0.1 to 0.5 seconds afte the stimulus onset. Sampling rate 100 as in the simulation","category":"page"},{"location":"generated/tutorials/overlapcorrectedLDA/","page":"Overlap corrected LDA","title":"Overlap corrected LDA","text":"des = [Any => (@formula(0 ~ 1 + condition + continuous), firbasis((-0.1, 1.0), 100))];\nnothing #hide","category":"page"},{"location":"generated/tutorials/overlapcorrectedLDA/","page":"Overlap corrected LDA","title":"Overlap corrected LDA","text":"Fitting and visualizing a single channel of the model","category":"page"},{"location":"generated/tutorials/overlapcorrectedLDA/","page":"Overlap corrected LDA","title":"Overlap corrected LDA","text":"uf = Unfold.fit(UnfoldModel, des, evt, dat[1, :]);\nplot_erp(coeftable(uf))","category":"page"},{"location":"generated/tutorials/overlapcorrectedLDA/#Fitting-the-Overlap-corrected-LDA-model","page":"Overlap corrected LDA","title":"Fitting the Overlap-corrected LDA model","text":"","category":"section"},{"location":"generated/tutorials/overlapcorrectedLDA/","page":"Overlap corrected LDA","title":"Overlap corrected LDA","text":"Following the MLJ Modelzoo we have to do the following to load an LDA model","category":"page"},{"location":"generated/tutorials/overlapcorrectedLDA/","page":"Overlap corrected LDA","title":"Overlap corrected LDA","text":"using MLJ, MultivariateStats, MLJMultivariateStatsInterface\nLDA = @load LDA pkg = MultivariateStats\nuf_lda =\n    Unfold.fit(UnfoldDecodingModel, des, evt, dat, LDA(), Any => :condition; nfolds = 2) # 2 folds to speed up computation\nplot_erp(coeftable(uf_lda); mapping = (; color = :coefname))","category":"page"},{"location":"generated/tutorials/overlapcorrectedLDA/","page":"Overlap corrected LDA","title":"Overlap corrected LDA","text":"Voila, the model classified the correct period.","category":"page"},{"location":"generated/tutorials/overlapcorrectedLDA/","page":"Overlap corrected LDA","title":"Overlap corrected LDA","text":"","category":"page"},{"location":"generated/tutorials/overlapcorrectedLDA/","page":"Overlap corrected LDA","title":"Overlap corrected LDA","text":"This page was generated using Literate.jl.","category":"page"}]
}
